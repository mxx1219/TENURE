public static OptionBuilder withArgName ( String name ) { rank2fixstart OptionBuilder . argName = name ; rank2fixend return instance ; }
public static OptionBuilder withArgName ( String name ) { OptionBuilder . argName = name ; rank2fixstart return instance ; rank2fixend }
public boolean hasArgName ( ) { rank2fixstart return ( this . argName != null && this . argName . length ( ) > 0 ) ; rank2fixend }
public static OptionBuilder hasArg ( ) { rank2fixstart OptionBuilder . numberOfArgs = 1 ; rank2fixend return instance ; }
public static OptionBuilder hasArg ( ) { OptionBuilder . numberOfArgs = 1 ; rank2fixstart return instance ; rank2fixend }
public String getDescription ( ) { rank2fixstart return this . description ; rank2fixend }
List helpOptions ( ) { rank2fixstart List opts = new ArrayList ( shortOpts . values ( ) ) ; rank2fixend Iterator iter = longOpts . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ; if ( ! opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; rank2fixstart Iterator iter = longOpts . values ( ) . iterator ( ) ; rank2fixend while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ; if ( ! opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; Iterator iter = longOpts . values ( ) . iterator ( ) ; rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend Object item = iter . next ( ) ; if ( ! opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; Iterator iter = longOpts . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ; if ( ! opts . contains ( item ) ) { opts . add ( item ) ; } } rank2fixstart return new ArrayList ( opts ) ; rank2fixend }
public static OptionBuilder withDescription ( String newDescription ) { rank2fixstart OptionBuilder . description = newDescription ; rank2fixend return instance ; }
public static OptionBuilder withDescription ( String newDescription ) { OptionBuilder . description = newDescription ; rank2fixstart return instance ; rank2fixend }
public boolean hasOption ( char opt ) { rank2fixstart return hasOption ( String . valueOf ( opt ) ) ; rank2fixend }
public String getOptionValue ( char opt ) { rank2fixstart return getOptionValue ( String . valueOf ( opt ) ) ; rank2fixend }
public static Option create ( char opt ) throws IllegalArgumentException { rank2fixstart return create ( String . valueOf ( opt ) ) ; rank2fixend }
rank2fixstart private OptionBuilder ( ) { rank2fixend }
rank2fixstart private OptionBuilder ( ) { rank2fixend }
private static void reset ( ) { rank2fixstart description = null ; rank2fixend argName = "STRING" ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; rank2fixstart argName = "STRING" ; rank2fixend longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; argName = "STRING" ; rank2fixstart longopt = null ; rank2fixend type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; argName = "STRING" ; longopt = null ; rank2fixstart type = null ; rank2fixend required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; argName = "STRING" ; longopt = null ; type = null ; rank2fixstart required = false ; rank2fixend numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; argName = "STRING" ; longopt = null ; type = null ; required = false ; rank2fixstart numberOfArgs = Option . UNINITIALIZED ; rank2fixend optionalArg = false ; valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; argName = "STRING" ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; rank2fixstart optionalArg = false ; rank2fixend valuesep = ( char ) 0 ; }
private static void reset ( ) { description = null ; argName = "STRING" ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; rank2fixstart valuesep = ( char ) 0 ; rank2fixend }
rank2fixstart private static void reset ( ) { rank2fixend description = null ; argName = "STRING" ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ; valuesep = ( char ) 0 ; }
public static Option create ( String opt ) throws IllegalArgumentException { rank2fixstart Option option = new Option ( opt , description ) ; rank2fixend option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; rank2fixstart option . setLongOpt ( longopt ) ; rank2fixend option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; rank2fixstart option . setRequired ( required ) ; rank2fixend option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; rank2fixstart option . setOptionalArg ( optionalArg ) ; rank2fixend option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; rank2fixstart option . setArgs ( numberOfArgs ) ; rank2fixend option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; rank2fixstart option . setType ( type ) ; rank2fixend option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; rank2fixstart option . setValueSeparator ( valuesep ) ; rank2fixend option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; rank2fixstart option . setArgName ( argName ) ; rank2fixend OptionBuilder . reset ( ) ; return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; rank2fixstart OptionBuilder . reset ( ) ; rank2fixend return option ; }
public static Option create ( String opt ) throws IllegalArgumentException { Option option = new Option ( opt , description ) ; option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; OptionBuilder . reset ( ) ; rank2fixstart return option ; rank2fixend }
public void setType ( Object type ) { rank2fixstart this . type = type ; rank2fixend }
rank2fixstart public void setType ( Object type ) { rank2fixend this . type = type ; }
public void setLongOpt ( String longOpt ) { rank2fixstart this . longOpt = longOpt ; rank2fixend }
rank2fixstart public void setLongOpt ( String longOpt ) { rank2fixend this . longOpt = longOpt ; }
public void setOptionalArg ( boolean optionalArg ) { rank2fixstart this . optionalArg = optionalArg ; rank2fixend }
rank2fixstart public void setOptionalArg ( boolean optionalArg ) { rank2fixend this . optionalArg = optionalArg ; }
public void setArgName ( String argName ) { rank2fixstart this . argName = argName ; rank2fixend }
rank2fixstart public void setArgName ( String argName ) { rank2fixend this . argName = argName ; }
public void setValueSeparator ( char sep ) { rank2fixstart this . valuesep = sep ; rank2fixend }
rank2fixstart public void setValueSeparator ( char sep ) { rank2fixend this . valuesep = sep ; }
public Option ( String opt , String description ) throws IllegalArgumentException { rank2fixstart this ( opt , null , false , description ) ; rank2fixend }
rank2fixstart public Option ( String opt , String description ) throws IllegalArgumentException { rank2fixend this ( opt , null , false , description ) ; }
public void setArgs ( int num ) { rank2fixstart this . numberOfArgs = num ; rank2fixend }
rank2fixstart public void setArgs ( int num ) { rank2fixend this . numberOfArgs = num ; }
public String getOpt ( ) { rank2fixstart return this . opt ; rank2fixend }
public void setRequired ( boolean required ) { rank2fixstart this . required = required ; rank2fixend }
rank2fixstart public void setRequired ( boolean required ) { rank2fixend this . required = required ; }
public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; String key = opt ; if ( names . containsKey ( opt ) ) { rank2fixstart key = ( String ) names . get ( opt ) ; rank2fixend } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { rank2fixstart char ch = opt . charAt ( 0 ) ; rank2fixend if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; rank2fixstart if ( ! isValidOpt ( ch ) ) { rank2fixend throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } rank2fixstart else if ( opt . length ( ) == 1 ) { rank2fixend char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
private static boolean isValidOpt ( char c ) { rank2fixstart return ( isValidChar ( c ) || ( c == "STRING" ) || ( c == "STRING" ) || c == "STRING" ) ; rank2fixend }
String getKey ( ) { if ( opt == null ) { return this . longOpt ; } rank2fixstart return this . opt ; rank2fixend }
public boolean hasArg ( ) { rank2fixstart return ( this . numberOfArgs > 0 ) || ( numberOfArgs == UNLIMITED_VALUES ) ; rank2fixend }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } rank2fixstart else if ( opt . length ( ) == 1 ) { rank2fixend char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
rank2fixstart static void validateOption ( String opt ) throws IllegalArgumentException { rank2fixend if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
private static boolean isValidChar ( char c ) { rank2fixstart return Character . isJavaIdentifierPart ( c ) ; rank2fixend }
rank2fixstart public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { rank2fixend OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { rank2fixstart OptionValidator . validateOption ( opt ) ; rank2fixend this . opt = opt ; this . longOpt = longOpt ; if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; rank2fixstart this . opt = opt ; rank2fixend this . longOpt = longOpt ; if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; this . opt = opt ; rank2fixstart this . longOpt = longOpt ; rank2fixend if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; rank2fixstart if ( hasArg ) { rank2fixend this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; if ( hasArg ) { this . numberOfArgs = 1 ; } rank2fixstart this . hasArg = hasArg ; rank2fixend this . description = description ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; rank2fixstart this . description = description ; rank2fixend }
rank2fixstart public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { rank2fixend OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }
String getKey ( ) { rank2fixstart if ( opt == null ) { rank2fixend return this . longOpt ; } return this . opt ; }
public boolean hasLongOpt ( ) { rank2fixstart return ( this . longOpt != null ) ; rank2fixend }
public boolean isRequired ( ) { rank2fixstart return this . required ; rank2fixend }
static void validateOption ( String opt ) throws IllegalArgumentException { rank2fixstart if ( opt == null ) { rank2fixend return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
public Options addOption ( Option opt ) { rank2fixstart String key = opt . getKey ( ) ; rank2fixend if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; rank2fixstart if ( opt . hasLongOpt ( ) ) { rank2fixend longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } rank2fixstart if ( opt . isRequired ( ) ) { rank2fixend if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } rank2fixstart shortOpts . put ( key , opt ) ; rank2fixend return this ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; rank2fixstart return this ; rank2fixend }
rank2fixstart public Options ( ) { rank2fixend }
rank2fixstart public Options ( ) { rank2fixend }
public static OptionBuilder withLongOpt ( String newLongopt ) { rank2fixstart OptionBuilder . longopt = newLongopt ; rank2fixend return instance ; }
public static OptionBuilder withLongOpt ( String newLongopt ) { OptionBuilder . longopt = newLongopt ; rank2fixstart return instance ; rank2fixend }
public String getOptionValue ( String opt ) { rank2fixstart String [ ] values = getOptionValues ( opt ) ; rank2fixend return ( values == null ) ? null : values [ 0 ] ; }
public String getOptionValue ( String opt ) { String [ ] values = getOptionValues ( opt ) ; rank2fixstart return ( values == null ) ? null : values [ 0 ] ; rank2fixend }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { rank2fixstart tokens . add ( token ) ; rank2fixend } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { rank2fixstart if ( stopAtNonOption ) { rank2fixend process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
public String [ ] getOptionValues ( String opt ) { rank2fixstart opt = Util . stripLeadingHyphens ( opt ) ; rank2fixend String key = opt ; if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; }
public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; rank2fixstart String key = opt ; rank2fixend if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; }
public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; String key = opt ; rank2fixstart if ( names . containsKey ( opt ) ) { rank2fixend key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; }
public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; String key = opt ; if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } rank2fixstart if ( options . containsKey ( key ) ) { rank2fixend return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } return null ; }
public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; String key = opt ; if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { rank2fixstart return ( ( Option ) options . get ( key ) ) . getValues ( ) ; rank2fixend } return null ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { rank2fixstart processOptionToken ( token , stopAtNonOption ) ; rank2fixend } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
private void processOptionToken ( String token , boolean stopAtNonOption ) { rank2fixstart if ( this . options . hasOption ( token ) ) { rank2fixend currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; } }
private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { rank2fixstart currentOption = this . options . getOption ( token ) ; rank2fixend tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; } }
private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; rank2fixstart tokens . add ( token ) ; rank2fixend } else if ( stopAtNonOption ) { eatTheRest = true ; } }
rank2fixstart private void processOptionToken ( String token , boolean stopAtNonOption ) { rank2fixend if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { rank2fixstart opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; rank2fixend } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } rank2fixstart catch ( RuntimeException exp ) { rank2fixend iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
rank2fixstart public void processArgs ( Option opt , ListIterator iter ) throws ParseException { rank2fixend while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
static String stripLeadingAndTrailingQuotes ( String str ) { rank2fixstart if ( str . startsWith ( "STRING" ) ) { rank2fixend str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith ( "STRING" ) ) { str = str . substring ( 0 , str . length ( ) - 1 ) ; } return str ; }
static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( "STRING" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } rank2fixstart if ( str . endsWith ( "STRING" ) ) { rank2fixend str = str . substring ( 0 , str . length ( ) - 1 ) ; } return str ; }
static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( "STRING" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith ( "STRING" ) ) { str = str . substring ( 0 , str . length ( ) - 1 ) ; } rank2fixstart return str ; rank2fixend }
public boolean hasValueSeparator ( ) { rank2fixstart return ( this . valuesep > 0 ) ; rank2fixend }
void addValue ( String value ) { rank2fixstart switch ( numberOfArgs ) { rank2fixend case UNINITIALIZED : throw new RuntimeException ( "STRING" ) ; default : processValue ( value ) ; } }
void addValue ( String value ) { switch ( numberOfArgs ) { case UNINITIALIZED : throw new RuntimeException ( "STRING" ) ; default : rank2fixstart processValue ( value ) ; rank2fixend } }
rank2fixstart void addValue ( String value ) { rank2fixend switch ( numberOfArgs ) { case UNINITIALIZED : throw new RuntimeException ( "STRING" ) ; default : processValue ( value ) ; } }
private void processValue ( String value ) { rank2fixstart if ( hasValueSeparator ( ) ) { rank2fixend char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } rank2fixstart add ( value ) ; rank2fixend }
rank2fixstart private void processValue ( String value ) { rank2fixend if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void add ( String value ) { rank2fixstart if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) { rank2fixend throw new RuntimeException ( "STRING" ) ; } this . values . add ( value ) ; }
private void add ( String value ) { if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) { throw new RuntimeException ( "STRING" ) ; } rank2fixstart this . values . add ( value ) ; rank2fixend }
rank2fixstart private void add ( String value ) { rank2fixend if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) { throw new RuntimeException ( "STRING" ) ; } this . values . add ( value ) ; }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { rank2fixstart String str = ( String ) iter . next ( ) ; rank2fixend if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; rank2fixstart if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { rank2fixend iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } rank2fixstart if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { rank2fixend throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { rank2fixstart processArgs ( opt , iter ) ; rank2fixend } cmd . addOption ( opt ) ; }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "STRING" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "STRING" ) ) { return str . substring ( 1 , str . length ( ) ) ; } rank2fixstart return str ; rank2fixend }
public String [ ] getValues ( ) { rank2fixstart return hasNoValues ( ) ? null : ( String [ ] ) this . values . toArray ( new String [ ] { } ) ; rank2fixend }
private boolean hasNoValues ( ) { rank2fixstart return this . values . size ( ) == 0 ; rank2fixend }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { rank2fixstart int tokenLength = token . length ( ) ; rank2fixend if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; rank2fixstart if ( tokenLength == 2 ) { rank2fixend processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } rank2fixstart else if ( token . startsWith ( "STRING" ) ) { rank2fixend int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } rank2fixstart else if ( "STRING" . equals ( token ) ) { rank2fixend processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } rank2fixstart else if ( token . startsWith ( "STRING" ) ) { rank2fixend int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
public boolean hasOption ( String opt ) { rank2fixstart return options . containsKey ( opt ) ; rank2fixend }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { rank2fixstart token = ( String ) iter . next ( ) ; rank2fixend if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; rank2fixstart if ( token . startsWith ( "STRING" ) ) { rank2fixend if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } rank2fixstart gobble ( iter ) ; rank2fixend } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
private void gobble ( Iterator iter ) { rank2fixstart if ( eatTheRest ) { rank2fixend while ( iter . hasNext ( ) ) { tokens . add ( iter . next ( ) ) ; } } }
rank2fixstart private void gobble ( Iterator iter ) { rank2fixend if ( eatTheRest ) { while ( iter . hasNext ( ) ) { tokens . add ( iter . next ( ) ) ; } } }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "STRING" ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "STRING" ) ) { rank2fixstart return str . substring ( 1 , str . length ( ) ) ; rank2fixend } return str ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { rank2fixstart longOpts . put ( opt . getLongOpt ( ) , opt ) ; rank2fixend } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
private void init ( ) { rank2fixstart eatTheRest = false ; rank2fixend tokens . clear ( ) ; currentOption = null ; }
private void init ( ) { eatTheRest = false ; rank2fixstart tokens . clear ( ) ; rank2fixend currentOption = null ; }
private void init ( ) { eatTheRest = false ; tokens . clear ( ) ; rank2fixstart currentOption = null ; rank2fixend }
rank2fixstart private void init ( ) { rank2fixend eatTheRest = false ; tokens . clear ( ) ; currentOption = null ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { rank2fixstart init ( ) ; rank2fixend this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; rank2fixstart this . options = options ; rank2fixend Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; rank2fixstart Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; rank2fixend String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; rank2fixstart String token = null ; rank2fixend while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } rank2fixstart return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; rank2fixend }
public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { rank2fixstart return ( Option ) shortOpts . get ( opt ) ; rank2fixend } return ( Option ) longOpts . get ( opt ) ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; rank2fixstart return cmd ; rank2fixend }
private void processProperties ( Properties properties ) { if ( properties == null ) { rank2fixstart return ; rank2fixend } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
rank2fixstart private void checkRequiredOptions ( ) throws MissingOptionException { rank2fixend if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } rank2fixstart processProperties ( properties ) ; rank2fixend checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; rank2fixstart checkRequiredOptions ( ) ; rank2fixend return cmd ; }
private void processProperties ( Properties properties ) { rank2fixstart if ( properties == null ) { rank2fixend return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void checkRequiredOptions ( ) throws MissingOptionException { rank2fixstart if ( requiredOptions . size ( ) > 0 ) { rank2fixend Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "STRING" ) ) { return str . substring ( 2 , str . length ( ) ) ; } rank2fixstart else if ( str . startsWith ( "STRING" ) ) { rank2fixend return str . substring ( 1 , str . length ( ) ) ; } return str ; }
public CommandLine parse ( Options options , String [ ] arguments ) throws ParseException { rank2fixstart return parse ( options , arguments , null , false ) ; rank2fixend }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } rank2fixstart cmd . addOption ( opt ) ; rank2fixend }
rank2fixstart private void processOption ( String arg , ListIterator iter ) throws ParseException { rank2fixend boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
public int hashCode ( ) { int result ; rank2fixstart result = ( opt != null ? opt . hashCode ( ) : 0 ) ; rank2fixend result = 31 * result + ( longOpt != null ? longOpt . hashCode ( ) : 0 ) ; return result ; }
public int hashCode ( ) { int result ; result = ( opt != null ? opt . hashCode ( ) : 0 ) ; rank2fixstart result = 31 * result + ( longOpt != null ? longOpt . hashCode ( ) : 0 ) ; rank2fixend return result ; }
public int hashCode ( ) { int result ; result = ( opt != null ? opt . hashCode ( ) : 0 ) ; result = 31 * result + ( longOpt != null ? longOpt . hashCode ( ) : 0 ) ; rank2fixstart return result ; rank2fixend }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } rank2fixstart if ( eatTheRest ) { rank2fixend while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; rank2fixstart while ( iterator . hasNext ( ) ) { rank2fixend String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
void addOption ( Option opt ) { rank2fixstart hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; rank2fixend String key = opt . getKey ( ) ; if ( key == null ) { key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; }
void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; rank2fixstart String key = opt . getKey ( ) ; rank2fixend if ( key == null ) { key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; }
void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; rank2fixstart if ( key == null ) { rank2fixend key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; }
void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; if ( key == null ) { key = opt . getLongOpt ( ) ; } else { rank2fixstart names . put ( opt . getLongOpt ( ) , key ) ; rank2fixend } options . put ( key , opt ) ; }
void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; if ( key == null ) { key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } rank2fixstart options . put ( key , opt ) ; rank2fixend }
rank2fixstart void addOption ( Option opt ) { rank2fixend hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; if ( key == null ) { key = opt . getLongOpt ( ) ; } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; }
public boolean hasOption ( String opt ) { rank2fixstart opt = Util . stripLeadingHyphens ( opt ) ; rank2fixend return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }
public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; rank2fixstart return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; rank2fixend }
public OptionGroup getOptionGroup ( Option opt ) { rank2fixstart return ( OptionGroup ) optionGroups . get ( opt . getKey ( ) ) ; rank2fixend }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { rank2fixstart if ( stopAtNonOption && ! options . hasOption ( t ) ) { rank2fixend eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { rank2fixstart processOption ( t , iterator ) ; rank2fixend } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { rank2fixstart boolean hasOption = options . hasOption ( arg ) ; rank2fixend if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; rank2fixstart if ( ! hasOption ) { rank2fixend throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } rank2fixstart final Option opt = options . getOption ( arg ) ; rank2fixend if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; rank2fixstart if ( opt . isRequired ( ) ) { rank2fixend requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } rank2fixstart if ( options . getOptionGroup ( opt ) != null ) { rank2fixend OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } rank2fixstart if ( opt . hasArg ( ) ) { rank2fixend processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
public Option getOption ( String opt ) { rank2fixstart opt = Util . stripLeadingHyphens ( opt ) ; rank2fixend if ( shortOpts . containsKey ( opt ) ) { return ( Option ) shortOpts . get ( opt ) ; } return ( Option ) longOpts . get ( opt ) ; }
public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; rank2fixstart if ( shortOpts . containsKey ( opt ) ) { rank2fixend return ( Option ) shortOpts . get ( opt ) ; } return ( Option ) longOpts . get ( opt ) ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { rank2fixstart String t = ( String ) iterator . next ( ) ; rank2fixend if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; rank2fixstart if ( "STRING" . equals ( t ) ) { rank2fixend eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } rank2fixstart else if ( "STRING" . equals ( t ) ) { rank2fixend if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } rank2fixstart else if ( t . startsWith ( "STRING" ) ) { rank2fixend if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
static String stripLeadingHyphens ( String str ) { rank2fixstart if ( str . startsWith ( "STRING" ) ) { rank2fixend return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith ( "STRING" ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
public String getLongOpt ( ) { rank2fixstart return this . longOpt ; rank2fixend }
public List getRequiredOptions ( ) { rank2fixstart return requiredOpts ; rank2fixend }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { rank2fixstart this . options = options ; rank2fixend requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; rank2fixstart requiredOptions = options . getRequiredOptions ( ) ; rank2fixend cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; rank2fixstart cmd = new CommandLine ( ) ; rank2fixend boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; rank2fixstart boolean eatTheRest = false ; rank2fixend if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; rank2fixstart if ( arguments == null ) { rank2fixend arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } rank2fixstart List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; rank2fixend ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; rank2fixstart ListIterator iterator = tokenList . listIterator ( ) ; rank2fixend while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; rank2fixstart while ( iterator . hasNext ( ) ) { rank2fixend String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
rank2fixstart CommandLine ( ) { rank2fixend }
rank2fixstart CommandLine ( ) { rank2fixend }
public static OptionBuilder hasArg ( boolean hasArg ) { rank2fixstart OptionBuilder . numberOfArgs = ( hasArg == true ) ? 1 : Option . UNINITIALIZED ; rank2fixend return instance ; }
public static OptionBuilder hasArg ( boolean hasArg ) { OptionBuilder . numberOfArgs = ( hasArg == true ) ? 1 : Option . UNINITIALIZED ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder isRequired ( ) { rank2fixstart OptionBuilder . required = true ; rank2fixend return instance ; }
public static OptionBuilder isRequired ( ) { OptionBuilder . required = true ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder withValueSeparator ( char sep ) { rank2fixstart OptionBuilder . valuesep = sep ; rank2fixend return instance ; }
public static OptionBuilder withValueSeparator ( char sep ) { OptionBuilder . valuesep = sep ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder withValueSeparator ( ) { rank2fixstart OptionBuilder . valuesep = "STRING" ; rank2fixend return instance ; }
public static OptionBuilder withValueSeparator ( ) { OptionBuilder . valuesep = "STRING" ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder isRequired ( boolean newRequired ) { rank2fixstart OptionBuilder . required = newRequired ; rank2fixend return instance ; }
public static OptionBuilder isRequired ( boolean newRequired ) { OptionBuilder . required = newRequired ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder hasArgs ( ) { rank2fixstart OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; rank2fixend return instance ; }
public static OptionBuilder hasArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder hasArgs ( int num ) { rank2fixstart OptionBuilder . numberOfArgs = num ; rank2fixend return instance ; }
public static OptionBuilder hasArgs ( int num ) { OptionBuilder . numberOfArgs = num ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder hasOptionalArg ( ) { rank2fixstart OptionBuilder . numberOfArgs = 1 ; rank2fixend OptionBuilder . optionalArg = true ; return instance ; }
public static OptionBuilder hasOptionalArg ( ) { OptionBuilder . numberOfArgs = 1 ; rank2fixstart OptionBuilder . optionalArg = true ; rank2fixend return instance ; }
public static OptionBuilder hasOptionalArg ( ) { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder hasOptionalArgs ( ) { rank2fixstart OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; rank2fixend OptionBuilder . optionalArg = true ; return instance ; }
public static OptionBuilder hasOptionalArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; rank2fixstart OptionBuilder . optionalArg = true ; rank2fixend return instance ; }
public static OptionBuilder hasOptionalArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder hasOptionalArgs ( int numArgs ) { rank2fixstart OptionBuilder . numberOfArgs = numArgs ; rank2fixend OptionBuilder . optionalArg = true ; return instance ; }
public static OptionBuilder hasOptionalArgs ( int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; rank2fixstart OptionBuilder . optionalArg = true ; rank2fixend return instance ; }
public static OptionBuilder hasOptionalArgs ( int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ; rank2fixstart return instance ; rank2fixend }
public static OptionBuilder withType ( Object newType ) { rank2fixstart OptionBuilder . type = newType ; rank2fixend return instance ; }
public static OptionBuilder withType ( Object newType ) { OptionBuilder . type = newType ; rank2fixstart return instance ; rank2fixend }
public static Option create ( ) throws IllegalArgumentException { rank2fixstart if ( longopt == null ) { rank2fixend throw new IllegalArgumentException ( "STRING" ) ; } return create ( null ) ; }
public static Option create ( ) throws IllegalArgumentException { if ( longopt == null ) { rank2fixstart throw new IllegalArgumentException ( "STRING" ) ; rank2fixend } return create ( null ) ; }
public static Option create ( ) throws IllegalArgumentException { if ( longopt == null ) { throw new IllegalArgumentException ( "STRING" ) ; } rank2fixstart return create ( null ) ; rank2fixend }
public Option ( String opt , boolean hasArg , String description ) throws IllegalArgumentException { rank2fixstart this ( opt , null , hasArg , description ) ; rank2fixend }
rank2fixstart public Option ( String opt , boolean hasArg , String description ) throws IllegalArgumentException { rank2fixend this ( opt , null , hasArg , description ) ; }
public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException { OptionValidator . validateOption ( opt ) ; this . opt = opt ; this . longOpt = longOpt ; if ( hasArg ) { rank2fixstart this . numberOfArgs = 1 ; rank2fixend } this . hasArg = hasArg ; this . description = description ; }
public int getId ( ) { rank2fixstart return getKey ( ) . charAt ( 0 ) ; rank2fixend }
String getKey ( ) { if ( opt == null ) { rank2fixstart return this . longOpt ; rank2fixend } return this . opt ; }
public Object getType ( ) { rank2fixstart return this . type ; rank2fixend }
public boolean hasOptionalArg ( ) { rank2fixstart return this . optionalArg ; rank2fixend }
public void setDescription ( String description ) { rank2fixstart this . description = description ; rank2fixend }
rank2fixstart public void setDescription ( String description ) { rank2fixend this . description = description ; }
public String getArgName ( ) { rank2fixstart return this . argName ; rank2fixend }
public boolean hasArgs ( ) { rank2fixstart return ( this . numberOfArgs > 1 ) || ( this . numberOfArgs == UNLIMITED_VALUES ) ; rank2fixend }
public char getValueSeparator ( ) { rank2fixstart return this . valuesep ; rank2fixend }
public int getArgs ( ) { rank2fixstart return this . numberOfArgs ; rank2fixend }
void addValue ( String value ) { switch ( numberOfArgs ) { case UNINITIALIZED : rank2fixstart throw new RuntimeException ( "STRING" ) ; rank2fixend default : processValue ( value ) ; } }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { rank2fixstart char sep = getValueSeparator ( ) ; rank2fixend int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; rank2fixstart int index = value . indexOf ( sep ) ; rank2fixend while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; rank2fixstart while ( index != - 1 ) { rank2fixend if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { rank2fixstart if ( values . size ( ) == ( numberOfArgs - 1 ) ) { rank2fixend break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { rank2fixstart break ; rank2fixend } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } rank2fixstart add ( value . substring ( 0 , index ) ) ; rank2fixend value = value . substring ( index + 1 ) ; index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; rank2fixstart value = value . substring ( index + 1 ) ; rank2fixend index = value . indexOf ( sep ) ; } } add ( value ) ; }
private void processValue ( String value ) { if ( hasValueSeparator ( ) ) { char sep = getValueSeparator ( ) ; int index = value . indexOf ( sep ) ; while ( index != - 1 ) { if ( values . size ( ) == ( numberOfArgs - 1 ) ) { break ; } add ( value . substring ( 0 , index ) ) ; value = value . substring ( index + 1 ) ; rank2fixstart index = value . indexOf ( sep ) ; rank2fixend } } add ( value ) ; }
private void add ( String value ) { if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) { rank2fixstart throw new RuntimeException ( "STRING" ) ; rank2fixend } this . values . add ( value ) ; }
public String getValue ( ) { rank2fixstart return hasNoValues ( ) ? null : ( String ) this . values . get ( 0 ) ; rank2fixend }
public String getValue ( int index ) throws IndexOutOfBoundsException { rank2fixstart return hasNoValues ( ) ? null : ( String ) this . values . get ( index ) ; rank2fixend }
public String getValue ( String defaultValue ) { rank2fixstart String value = getValue ( ) ; rank2fixend return ( value != null ) ? value : defaultValue ; }
public String getValue ( String defaultValue ) { String value = getValue ( ) ; rank2fixstart return ( value != null ) ? value : defaultValue ; rank2fixend }
public java . util . List getValuesList ( ) { rank2fixstart return this . values ; rank2fixend }
public String toString ( ) { rank2fixstart StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; rank2fixend buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; rank2fixstart buf . append ( this . opt ) ; rank2fixend if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; rank2fixstart if ( this . longOpt != null ) { rank2fixend buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { rank2fixstart buf . append ( "STRING" ) . append ( this . longOpt ) ; rank2fixend } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } rank2fixstart buf . append ( "STRING" ) ; rank2fixend if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; rank2fixstart if ( hasArg ) { rank2fixend buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { rank2fixstart buf . append ( "STRING" ) ; rank2fixend } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } rank2fixstart buf . append ( "STRING" ) . append ( this . description ) ; rank2fixend if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; rank2fixstart if ( this . type != null ) { rank2fixend buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { rank2fixstart buf . append ( "STRING" ) . append ( this . type ) ; rank2fixend } buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } rank2fixstart buf . append ( "STRING" ) ; rank2fixend return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) . append ( "STRING" ) ; buf . append ( this . opt ) ; if ( this . longOpt != null ) { buf . append ( "STRING" ) . append ( this . longOpt ) ; } buf . append ( "STRING" ) ; if ( hasArg ) { buf . append ( "STRING" ) ; } buf . append ( "STRING" ) . append ( this . description ) ; if ( this . type != null ) { buf . append ( "STRING" ) . append ( this . type ) ; } buf . append ( "STRING" ) ; rank2fixstart return buf . toString ( ) ; rank2fixend }
public boolean equals ( Object o ) { rank2fixstart if ( this == o ) { rank2fixend return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { rank2fixstart return true ; rank2fixend } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } rank2fixstart if ( o == null || getClass ( ) != o . getClass ( ) ) { rank2fixend return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { rank2fixstart return false ; rank2fixend } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } rank2fixstart Option option = ( Option ) o ; rank2fixend if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; rank2fixstart if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { rank2fixend return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { rank2fixstart return false ; rank2fixend } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } rank2fixstart if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { rank2fixend return false ; } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { rank2fixstart return false ; rank2fixend } return true ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Option option = ( Option ) o ; if ( opt != null ? ! opt . equals ( option . opt ) : option . opt != null ) { return false ; } if ( longOpt != null ? ! longOpt . equals ( option . longOpt ) : option . longOpt != null ) { return false ; } rank2fixstart return true ; rank2fixend }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { rank2fixstart return ; rank2fixend } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { rank2fixstart throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; rank2fixend } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { rank2fixstart char [ ] chars = opt . toCharArray ( ) ; rank2fixend for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; rank2fixstart for ( int i = 0 ; i < chars . length ; i ++ ) { rank2fixend if ( ! isValidChar ( chars [ i ] ) ) { throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { rank2fixstart if ( ! isValidChar ( chars [ i ] ) ) { rank2fixend throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; } } } }
static void validateOption ( String opt ) throws IllegalArgumentException { if ( opt == null ) { return ; } else if ( opt . length ( ) == 1 ) { char ch = opt . charAt ( 0 ) ; if ( ! isValidOpt ( ch ) ) { throw new IllegalArgumentException ( "STRING" + ch + "STRING" ) ; } } else { char [ ] chars = opt . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( ! isValidChar ( chars [ i ] ) ) { rank2fixstart throw new IllegalArgumentException ( "STRING" + chars [ i ] + "STRING" ) ; rank2fixend } } } }
public Options addOptionGroup ( OptionGroup group ) { rank2fixstart Iterator options = group . getOptions ( ) . iterator ( ) ; rank2fixend if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; rank2fixstart if ( group . isRequired ( ) ) { rank2fixend requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { rank2fixstart requiredOpts . add ( group ) ; rank2fixend } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } rank2fixstart while ( options . hasNext ( ) ) { rank2fixend Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { rank2fixstart Option option = ( Option ) options . next ( ) ; rank2fixend option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; rank2fixstart option . setRequired ( false ) ; rank2fixend addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; rank2fixstart addOption ( option ) ; rank2fixend optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; rank2fixstart optionGroups . put ( option . getKey ( ) , group ) ; rank2fixend } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } rank2fixstart while ( options . hasNext ( ) ) { rank2fixend Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }
public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ; if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option = ( Option ) options . next ( ) ; option . setRequired ( false ) ; addOption ( option ) ; optionGroups . put ( option . getKey ( ) , group ) ; } rank2fixstart return this ; rank2fixend }
Collection getOptionGroups ( ) { rank2fixstart return new HashSet ( optionGroups . values ( ) ) ; rank2fixend }
public Options addOption ( String opt , boolean hasArg , String description ) { rank2fixstart addOption ( opt , null , hasArg , description ) ; rank2fixend return this ; }
public Options addOption ( String opt , boolean hasArg , String description ) { addOption ( opt , null , hasArg , description ) ; rank2fixstart return this ; rank2fixend }
public Options addOption ( String opt , String longOpt , boolean hasArg , String description ) { rank2fixstart addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; rank2fixend return this ; }
public Options addOption ( String opt , String longOpt , boolean hasArg , String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ; rank2fixstart return this ; rank2fixend }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { rank2fixstart if ( requiredOpts . contains ( key ) ) { rank2fixend requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { rank2fixstart requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; rank2fixend } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ; return this ; }
public Options addOption ( Option opt ) { String key = opt . getKey ( ) ; if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; } if ( opt . isRequired ( ) ) { if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; } rank2fixstart requiredOpts . add ( key ) ; rank2fixend } shortOpts . put ( key , opt ) ; return this ; }
public Collection getOptions ( ) { rank2fixstart return Collections . unmodifiableCollection ( helpOptions ( ) ) ; rank2fixend }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; Iterator iter = longOpts . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { rank2fixstart Object item = iter . next ( ) ; rank2fixend if ( ! opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; Iterator iter = longOpts . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ; rank2fixstart if ( ! opts . contains ( item ) ) { rank2fixend opts . add ( item ) ; } } return new ArrayList ( opts ) ; }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; Iterator iter = longOpts . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ; if ( ! opts . contains ( item ) ) { rank2fixstart opts . add ( item ) ; rank2fixend } } return new ArrayList ( opts ) ; }
List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ; Iterator iter = longOpts . values ( ) . iterator ( ) ; rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend Object item = iter . next ( ) ; if ( ! opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }
public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; if ( shortOpts . containsKey ( opt ) ) { return ( Option ) shortOpts . get ( opt ) ; } rank2fixstart return ( Option ) longOpts . get ( opt ) ; rank2fixend }
public String toString ( ) { rank2fixstart StringBuffer buf = new StringBuffer ( ) ; rank2fixend buf . append ( "STRING" ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append ( "STRING" ) ; buf . append ( longOpts ) ; buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; rank2fixstart buf . append ( "STRING" ) ; rank2fixend buf . append ( shortOpts . toString ( ) ) ; buf . append ( "STRING" ) ; buf . append ( longOpts ) ; buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "STRING" ) ; rank2fixstart buf . append ( shortOpts . toString ( ) ) ; rank2fixend buf . append ( "STRING" ) ; buf . append ( longOpts ) ; buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "STRING" ) ; buf . append ( shortOpts . toString ( ) ) ; rank2fixstart buf . append ( "STRING" ) ; rank2fixend buf . append ( longOpts ) ; buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "STRING" ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append ( "STRING" ) ; rank2fixstart buf . append ( longOpts ) ; rank2fixend buf . append ( "STRING" ) ; return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "STRING" ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append ( "STRING" ) ; buf . append ( longOpts ) ; rank2fixstart buf . append ( "STRING" ) ; rank2fixend return buf . toString ( ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( "STRING" ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append ( "STRING" ) ; buf . append ( longOpts ) ; buf . append ( "STRING" ) ; rank2fixstart return buf . toString ( ) ; rank2fixend }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties ) throws ParseException { rank2fixstart return parse ( options , arguments , properties , false ) ; rank2fixend }
public CommandLine parse ( Options options , String [ ] arguments , boolean stopAtNonOption ) throws ParseException { rank2fixstart return parse ( options , arguments , null , stopAtNonOption ) ; rank2fixend }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { rank2fixstart arguments = new String [ 0 ] ; rank2fixend } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { rank2fixstart eatTheRest = true ; rank2fixend } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { rank2fixstart if ( stopAtNonOption ) { rank2fixend eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { rank2fixstart eatTheRest = true ; rank2fixend } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { rank2fixstart cmd . addArg ( t ) ; rank2fixend } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { rank2fixstart eatTheRest = true ; rank2fixend cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; rank2fixstart cmd . addArg ( t ) ; rank2fixend } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { rank2fixstart cmd . addArg ( t ) ; rank2fixend if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; rank2fixstart if ( stopAtNonOption ) { rank2fixend eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { rank2fixstart eatTheRest = true ; rank2fixend } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { rank2fixstart while ( iterator . hasNext ( ) ) { rank2fixend String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { rank2fixstart String str = ( String ) iterator . next ( ) ; rank2fixend if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; rank2fixstart if ( ! "STRING" . equals ( str ) ) { rank2fixend cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { rank2fixstart cmd . addArg ( str ) ; rank2fixend } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
public CommandLine parse ( Options options , String [ ] arguments , Properties properties , boolean stopAtNonOption ) throws ParseException { this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ; boolean eatTheRest = false ; if ( arguments == null ) { arguments = new String [ 0 ] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ; ListIterator iterator = tokenList . listIterator ( ) ; while ( iterator . hasNext ( ) ) { String t = ( String ) iterator . next ( ) ; if ( "STRING" . equals ( t ) ) { eatTheRest = true ; } else if ( "STRING" . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } } else if ( t . startsWith ( "STRING" ) ) { if ( stopAtNonOption && ! options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } } else { cmd . addArg ( t ) ; if ( stopAtNonOption ) { eatTheRest = true ; } } if ( eatTheRest ) { rank2fixstart while ( iterator . hasNext ( ) ) { rank2fixend String str = ( String ) iterator . next ( ) ; if ( ! "STRING" . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ; return cmd ; }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } rank2fixstart for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { rank2fixend String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { rank2fixstart String option = e . nextElement ( ) . toString ( ) ; rank2fixend if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; rank2fixstart if ( ! cmd . hasOption ( option ) ) { rank2fixend Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { rank2fixstart Option opt = options . getOption ( option ) ; rank2fixend String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; rank2fixstart String value = properties . getProperty ( option ) ; rank2fixend if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; rank2fixstart if ( opt . hasArg ( ) ) { rank2fixend if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { rank2fixstart if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { rank2fixend try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { rank2fixstart opt . addValue ( value ) ; rank2fixend } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } rank2fixstart catch ( RuntimeException exp ) { rank2fixend } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { rank2fixstart try { rank2fixend opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } rank2fixstart else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { rank2fixend break ; } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { rank2fixstart break ; rank2fixend } cmd . addOption ( opt ) ; } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } rank2fixstart cmd . addOption ( opt ) ; rank2fixend } } }
private void processProperties ( Properties properties ) { if ( properties == null ) { return ; } rank2fixstart for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { rank2fixend String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
rank2fixstart private void processProperties ( Properties properties ) { rank2fixend if ( properties == null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; String value = properties . getProperty ( option ) ; if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( ) == null ) || ( opt . getValues ( ) . length == 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) { } } } else if ( ! ( "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) || "STRING" . equalsIgnoreCase ( value ) ) ) { break ; } cmd . addOption ( opt ) ; } } }
private void checkRequiredOptions ( ) throws MissingOptionException { if ( requiredOptions . size ( ) > 0 ) { rank2fixstart Iterator iter = requiredOptions . iterator ( ) ; rank2fixend StringBuffer buff = new StringBuffer ( ) ; while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }
private void checkRequiredOptions ( ) throws MissingOptionException { if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; rank2fixstart StringBuffer buff = new StringBuffer ( ) ; rank2fixend while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }
private void checkRequiredOptions ( ) throws MissingOptionException { if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }
private void checkRequiredOptions ( ) throws MissingOptionException { if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; while ( iter . hasNext ( ) ) { rank2fixstart buff . append ( iter . next ( ) ) ; rank2fixend } throw new MissingOptionException ( buff . toString ( ) ) ; } }
private void checkRequiredOptions ( ) throws MissingOptionException { if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } rank2fixstart throw new MissingOptionException ( buff . toString ( ) ) ; rank2fixend } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { rank2fixstart iter . previous ( ) ; rank2fixend break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; rank2fixstart break ; rank2fixend } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } rank2fixstart try { rank2fixend opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { rank2fixstart iter . previous ( ) ; rank2fixend break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; rank2fixstart break ; rank2fixend } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; } }
public void processArgs ( Option opt , ListIterator iter ) throws ParseException { while ( iter . hasNext ( ) ) { String str = ( String ) iter . next ( ) ; if ( options . hasOption ( str ) && str . startsWith ( "STRING" ) ) { iter . previous ( ) ; break ; } try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str ) ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( ) == null ) && ! opt . hasOptionalArg ( ) ) { rank2fixstart throw new MissingArgumentException ( "STRING" + opt . getKey ( ) ) ; rank2fixend } }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { rank2fixstart throw new UnrecognizedOptionException ( "STRING" + arg ) ; rank2fixend } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { rank2fixstart requiredOptions . remove ( opt . getKey ( ) ) ; rank2fixend } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { rank2fixstart OptionGroup group = options . getOptionGroup ( opt ) ; rank2fixend if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; rank2fixstart if ( group . isRequired ( ) ) { rank2fixend requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { rank2fixstart requiredOptions . remove ( group ) ; rank2fixend } group . setSelected ( opt ) ; } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
private void processOption ( String arg , ListIterator iter ) throws ParseException { boolean hasOption = options . hasOption ( arg ) ; if ( ! hasOption ) { throw new UnrecognizedOptionException ( "STRING" + arg ) ; } final Option opt = options . getOption ( arg ) ; if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; } if ( options . getOptionGroup ( opt ) != null ) { OptionGroup group = options . getOptionGroup ( opt ) ; if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } rank2fixstart group . setSelected ( opt ) ; rank2fixend } if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; } cmd . addOption ( opt ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { rank2fixstart if ( token . indexOf ( "STRING" ) != - 1 ) { rank2fixend tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { rank2fixstart tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; rank2fixend tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; rank2fixstart tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; rank2fixend } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { rank2fixstart tokens . add ( token ) ; rank2fixend } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { rank2fixstart processSingleHyphen ( token ) ; rank2fixend } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } rank2fixstart else if ( options . hasOption ( token ) ) { rank2fixend tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { rank2fixstart tokens . add ( token ) ; rank2fixend } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { rank2fixstart burstToken ( token , stopAtNonOption ) ; rank2fixend } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; this . options = options ; Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ; while ( iter . hasNext ( ) ) { token = ( String ) iter . next ( ) ; if ( token . startsWith ( "STRING" ) ) { if ( token . indexOf ( "STRING" ) != - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( "STRING" ) ) ) ; tokens . add ( token . substring ( token . indexOf ( "STRING" ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } } else if ( "STRING" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( "STRING" ) ) { int tokenLength = token . length ( ) ; if ( tokenLength == 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; } else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { rank2fixstart process ( token ) ; rank2fixend } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String [ ] ) tokens . toArray ( new String [ ] { } ) ; }
private void gobble ( Iterator iter ) { if ( eatTheRest ) { rank2fixstart while ( iter . hasNext ( ) ) { rank2fixend tokens . add ( iter . next ( ) ) ; } } }
private void gobble ( Iterator iter ) { if ( eatTheRest ) { while ( iter . hasNext ( ) ) { rank2fixstart tokens . add ( iter . next ( ) ) ; rank2fixend } } }
private void process ( String value ) { rank2fixstart if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { rank2fixend if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { rank2fixstart if ( currentOption . hasArg ( ) ) { rank2fixend tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { rank2fixstart tokens . add ( value ) ; rank2fixend currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; rank2fixstart currentOption = null ; rank2fixend } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } rank2fixstart else if ( currentOption . hasArgs ( ) ) { rank2fixend tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { rank2fixstart tokens . add ( value ) ; rank2fixend } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { rank2fixstart eatTheRest = true ; rank2fixend tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; rank2fixstart tokens . add ( "STRING" ) ; rank2fixend tokens . add ( value ) ; } }
private void process ( String value ) { if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; rank2fixstart tokens . add ( value ) ; rank2fixend } }
rank2fixstart private void process ( String value ) { rank2fixend if ( ( currentOption != null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( "STRING" ) ; tokens . add ( value ) ; } }
private void processSingleHyphen ( String hyphen ) { rank2fixstart tokens . add ( hyphen ) ; rank2fixend }
rank2fixstart private void processSingleHyphen ( String hyphen ) { rank2fixend tokens . add ( hyphen ) ; }
private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } rank2fixstart else if ( stopAtNonOption ) { rank2fixend eatTheRest = true ; } }
private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { rank2fixstart eatTheRest = true ; rank2fixend } }
protected void burstToken ( String token , boolean stopAtNonOption ) { rank2fixstart int tokenLength = token . length ( ) ; rank2fixend for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; rank2fixstart for ( int i = 1 ; i < tokenLength ; i ++ ) { rank2fixend String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { rank2fixstart String ch = String . valueOf ( token . charAt ( i ) ) ; rank2fixend boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; rank2fixstart boolean hasOption = options . hasOption ( ch ) ; rank2fixend if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; rank2fixstart if ( hasOption ) { rank2fixend tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { rank2fixstart tokens . add ( "STRING" + ch ) ; rank2fixend currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; rank2fixstart currentOption = options . getOption ( ch ) ; rank2fixend if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; rank2fixstart if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { rank2fixend tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { rank2fixstart tokens . add ( token . substring ( i + 1 ) ) ; rank2fixend break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; rank2fixstart break ; rank2fixend } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } rank2fixstart else if ( stopAtNonOption ) { rank2fixend process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { rank2fixstart process ( token . substring ( i ) ) ; rank2fixend } else { tokens . add ( "STRING" + ch ) ; } } }
protected void burstToken ( String token , boolean stopAtNonOption ) { int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { rank2fixstart tokens . add ( "STRING" + ch ) ; rank2fixend } } }
rank2fixstart protected void burstToken ( String token , boolean stopAtNonOption ) { rank2fixend int tokenLength = token . length ( ) ; for ( int i = 1 ; i < tokenLength ; i ++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ; if ( hasOption ) { tokens . add ( "STRING" + ch ) ; currentOption = options . getOption ( ch ) ; if ( currentOption . hasArg ( ) && ( token . length ( ) != ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add ( "STRING" + ch ) ; } } }
public Object getOptionObject ( String opt ) { rank2fixstart String res = getOptionValue ( opt ) ; rank2fixend if ( ! options . containsKey ( opt ) ) { return null ; } Object type = ( ( Option ) options . get ( opt ) ) . getType ( ) ; return ( res == null ) ? null : TypeHandler . createValue ( res , type ) ; }
public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ; rank2fixstart if ( ! options . containsKey ( opt ) ) { rank2fixend return null ; } Object type = ( ( Option ) options . get ( opt ) ) . getType ( ) ; return ( res == null ) ? null : TypeHandler . createValue ( res , type ) ; }
public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ; if ( ! options . containsKey ( opt ) ) { rank2fixstart return null ; rank2fixend } Object type = ( ( Option ) options . get ( opt ) ) . getType ( ) ; return ( res == null ) ? null : TypeHandler . createValue ( res , type ) ; }
public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ; if ( ! options . containsKey ( opt ) ) { return null ; } rank2fixstart Object type = ( ( Option ) options . get ( opt ) ) . getType ( ) ; rank2fixend return ( res == null ) ? null : TypeHandler . createValue ( res , type ) ; }
public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ; if ( ! options . containsKey ( opt ) ) { return null ; } Object type = ( ( Option ) options . get ( opt ) ) . getType ( ) ; rank2fixstart return ( res == null ) ? null : TypeHandler . createValue ( res , type ) ; rank2fixend }
public Object getOptionObject ( char opt ) { rank2fixstart return getOptionObject ( String . valueOf ( opt ) ) ; rank2fixend }
public String [ ] getOptionValues ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; String key = opt ; if ( names . containsKey ( opt ) ) { key = ( String ) names . get ( opt ) ; } if ( options . containsKey ( key ) ) { return ( ( Option ) options . get ( key ) ) . getValues ( ) ; } rank2fixstart return null ; rank2fixend }
public String [ ] getOptionValues ( char opt ) { rank2fixstart return getOptionValues ( String . valueOf ( opt ) ) ; rank2fixend }
public String getOptionValue ( String opt , String defaultValue ) { rank2fixstart String answer = getOptionValue ( opt ) ; rank2fixend return ( answer != null ) ? answer : defaultValue ; }
public String getOptionValue ( String opt , String defaultValue ) { String answer = getOptionValue ( opt ) ; rank2fixstart return ( answer != null ) ? answer : defaultValue ; rank2fixend }
public String getOptionValue ( char opt , String defaultValue ) { rank2fixstart return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; rank2fixend }
public String [ ] getArgs ( ) { rank2fixstart String [ ] answer = new String [ args . size ( ) ] ; rank2fixend args . toArray ( answer ) ; return answer ; }
public String [ ] getArgs ( ) { String [ ] answer = new String [ args . size ( ) ] ; rank2fixstart args . toArray ( answer ) ; rank2fixend return answer ; }
public String [ ] getArgs ( ) { String [ ] answer = new String [ args . size ( ) ] ; args . toArray ( answer ) ; rank2fixstart return answer ; rank2fixend }
public List getArgList ( ) { rank2fixstart return args ; rank2fixend }
void addArg ( String arg ) { rank2fixstart args . add ( arg ) ; rank2fixend }
rank2fixstart void addArg ( String arg ) { rank2fixend args . add ( arg ) ; }
void addOption ( Option opt ) { hashcodeMap . put ( new Integer ( opt . hashCode ( ) ) , opt ) ; String key = opt . getKey ( ) ; if ( key == null ) { rank2fixstart key = opt . getLongOpt ( ) ; rank2fixend } else { names . put ( opt . getLongOpt ( ) , key ) ; } options . put ( key , opt ) ; }
public Iterator iterator ( ) { rank2fixstart return hashcodeMap . values ( ) . iterator ( ) ; rank2fixend }
public Option [ ] getOptions ( ) { rank2fixstart Collection processed = options . values ( ) ; rank2fixend Option [ ] optionsArray = new Option [ processed . size ( ) ] ; return ( Option [ ] ) processed . toArray ( optionsArray ) ; }
public Option [ ] getOptions ( ) { Collection processed = options . values ( ) ; rank2fixstart Option [ ] optionsArray = new Option [ processed . size ( ) ] ; rank2fixend return ( Option [ ] ) processed . toArray ( optionsArray ) ; }
public Option [ ] getOptions ( ) { Collection processed = options . values ( ) ; Option [ ] optionsArray = new Option [ processed . size ( ) ] ; rank2fixstart return ( Option [ ] ) processed . toArray ( optionsArray ) ; rank2fixend }
static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( "STRING" ) ) { rank2fixstart return str . substring ( 2 , str . length ( ) ) ; rank2fixend } else if ( str . startsWith ( "STRING" ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }
static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( "STRING" ) ) { rank2fixstart str = str . substring ( 1 , str . length ( ) ) ; rank2fixend } if ( str . endsWith ( "STRING" ) ) { str = str . substring ( 0 , str . length ( ) - 1 ) ; } return str ; }
static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( "STRING" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith ( "STRING" ) ) { rank2fixstart str = str . substring ( 0 , str . length ( ) - 1 ) ; rank2fixend } return str ; }
public ParseException ( String message ) { rank2fixstart super ( message ) ; rank2fixend }
rank2fixstart public ParseException ( String message ) { rank2fixend super ( message ) ; }
public MissingOptionException ( String message ) { rank2fixstart super ( message ) ; rank2fixend }
rank2fixstart public MissingOptionException ( String message ) { rank2fixend super ( message ) ; }
public MissingArgumentException ( String message ) { rank2fixstart super ( message ) ; rank2fixend }
rank2fixstart public MissingArgumentException ( String message ) { rank2fixend super ( message ) ; }
public UnrecognizedOptionException ( String message ) { rank2fixstart super ( message ) ; rank2fixend }
rank2fixstart public UnrecognizedOptionException ( String message ) { rank2fixend super ( message ) ; }
